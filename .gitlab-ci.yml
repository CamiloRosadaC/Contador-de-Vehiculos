# Definición de etapas del pipeline
stages:
  - test
  - build
  - deploy

# Variables globales
variables:
  # Variables para Docker
  DOCKER_REGISTRY: ${CI_REGISTRY}
  DOCKER_IMAGE_NAME: ${CI_REGISTRY_IMAGE}
  DOCKER_IMAGE_TAG: ${CI_COMMIT_SHA}
  
  # Variables para Python/pytest
  PYTHON_VERSION: "3.12"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  
  # Variables para el despliegue (estas se deben configurar en GitLab UI)
  # DO_SSH_KEY: SSH key para acceder al Droplet
  # DO_HOST: IP del Droplet
  # DO_USER: Usuario en el Droplet (normalmente root)
  # DOCKER_USERNAME: Usuario de Docker Registry
  # DOCKER_PASSWORD: Password/Token de Docker Registry

# Cache compartida para dependencias de Python
cache:
  paths:
    - .pip-cache/
    - .venv/

test:
  stage: test
  image: python:${PYTHON_VERSION}-slim
  before_script:
    # Instalar dependencias del sistema
    - apt-get update
    - apt-get install -y ffmpeg libsm6 libxext6
    # Crear entorno virtual y activarlo
    - python -m venv .venv
    - source .venv/bin/activate
    # Instalar dependencias de Python
    - pip install --upgrade pip
    - pip install pytest numpy supervision ultralytics
  script:
    - pytest tests/ -v
  only:
    - main
    - merge_requests

# Etapa: build
build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  before_script:
    - echo "${CI_REGISTRY_PASSWORD}" | docker login -u "${CI_REGISTRY_USER}" --password-stdin "${CI_REGISTRY}"
  script:
    - docker build -t ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} .
    - docker push ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
    # También taggeamos como latest si estamos en main
    - |
      if [ "$CI_COMMIT_BRANCH" = "main" ]; then
        docker tag ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKER_IMAGE_NAME}:latest
        docker push ${DOCKER_IMAGE_NAME}:latest
      fi
  only:
    - main
    - merge_requests

# Etapa: deploy
deploy:
  stage: deploy
  image: ubuntu:22.04
  before_script:
    # Instalamos openssh-client
    - apt-get update && apt-get install -y openssh-client
    # Configuramos SSH
    - eval $(ssh-agent -s)
    - echo "$DO_SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DO_HOST >> ~/.ssh/known_hosts
  script:
    # Script de despliegue
    - |
      ssh $DO_USER@$DO_HOST "
        # Login al registro de Docker
        echo \"${CI_REGISTRY_PASSWORD}\" | docker login -u \"${CI_REGISTRY_USER}\" --password-stdin \"${CI_REGISTRY}\"
        
        # Detenemos y eliminamos el contenedor anterior si existe
        docker ps -q --filter name=contador-vehiculos | grep -q . && docker stop contador-vehiculos
        docker container rm -f contador-vehiculos || true
        
        # Descargamos la nueva imagen
        docker pull ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
        
        # Ejecutamos el nuevo contenedor
        docker run -d \
          --name contador-vehiculos \
          --restart unless-stopped \
          -p 8501:8501 \
          ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
        
        # Limpiamos imágenes antiguas
        docker image prune -f
      "
  environment:
    name: production
    url: http://${DO_HOST}:8501
  only:
    - main
    